
## 1. **Extension Function Mapper** (Simple & Clean)

This is the most common and Kotlin-idiomatic way when mapping is straightforward.

### âœ… Use when:

- Mapping is simple.
    
- You donâ€™t need dependencies.
    
- You want concise, readable code.
    

### ğŸ§© Example:



```kotlin
fun UserDTO.toDomain(): User {
    return User(
        id = id ?: 0,
        name = username ?: "Unknown",
        email = email ?: "no-email@example.com"
    )
}
```

## ğŸ§± 2. **Mapper Interface with** `convert(F): T`

This is a more formal, testable approachâ€”great for larger projects or when using dependency injection (like Koin).

### âœ… Use when:

- You want consistency across mappers.
    
- You need to inject mappers.
    
- You want to unit test mapping logic.
    

### ğŸ§© Interface:



```kotlin
interface Mapper<F, T> {
    fun convert(from: F): T
}
```

just added this now so its not part of the code
```kotlin

fun <F,T> Mapper<F,T>.mapAll(list:List<F>) = list.map{map(it)}

```

### ğŸ§© Implementation:



```kotlin
class UserMapper : Mapper<UserDTO, User> {
    override fun convert(from: UserDTO): User {
        return User(
            id = from.id ?: 0,
            name = from.username ?: "Unknown",
            email = from.email ?: "no-email@example.com"
        )
    }
}
```

### ğŸ§© Usage:



```kotlin
val userMapper = UserMapper()
val user = userMapper.convert(userDTO)
```

## ğŸ§  3. **Mapper Class with Named Function (**`map`**,** `transform`**, etc.)**

This is similar to the interface approach but without enforcing a generic contract.

### âœ… Use when:

- You want flexibility without generics.
    
- You have multiple mapping methods in one class.
    

### ğŸ§© Example:



```kotlin
class UserMapper {
    fun map(dto: UserDTO): User {
        return User(
            id = dto.id ?: 0,
            name = dto.username ?: "Unknown",
            email = dto.email ?: "no-email@example.com"
        )
    }
}
```

## ğŸ” 4. **Bidirectional Mapper (DTO â†” Model)**

Sometimes you need to convert both waysâ€”especially for caching, local DB, or sending data back to the server.

### âœ… Use when:

- You need both DTO â†’ Model and Model â†’ DTO.
    
- Youâ€™re syncing with local DB or sending POST requests.
    

### ğŸ§© Example:



```kotlin
class UserMapper {
    fun toDomain(dto: UserDTO): User { ... }
    fun toDto(model: User): UserDTO { ... }
}
```

## ğŸ§ª 5. **Functional Mapper (Lambda)**

For very simple cases, you can use a lambda or function reference.

### âœ… Use when:

- You donâ€™t need a class.
    
- You want quick mapping in a repository or use case.
    

### ğŸ§© Example:



```kotlin
val userMapper: (UserDTO) -> User = { dto ->
    User(
        id = dto.id ?: 0,
        name = dto.username ?: "Unknown",
        email = dto.email ?: "no-email@example.com"
    )
}
```

## ğŸ§­ Which One Should You Use?

|Style|Best For|Testable?|DI-Friendly?|Verbosity|
|---|---|---|---|---|
|Extension Function|Simple apps|âŒ|âŒ|âœ… Minimal|
|Mapper Interface|Scalable architecture|âœ…|âœ…|âš ï¸ Verbose|
|Mapper Class|Flexible logic|âœ…|âœ…|âš–ï¸ Balanced|
|Bidirectional Mapper|Syncing or POST APIs|âœ…|âœ…|âš ï¸ Verbose|
|Functional Mapper|Quick one-off use|âŒ|âŒ|âœ… Minimal|

If youâ€™re using **Koin**, the interface or class-based mappers are great because you can inject them easily. Want me to show you how to register a mapper in Koin and use it in a repository?


## How to Provide Mappers in Koin

In Koin, you **donâ€™t annotate classes**. Instead, you **declare them in your module** like this:

### ğŸ§© Example: Declaring `UserMapper` in a Koin Module

kotlin

```
val appModule = module {
    single<Mapper<UserDTO, User>> { UserMapper() }
}
```

Or if you want to use the concrete type directly:

kotlin

```
val appModule = module {
    single { UserMapper() }
}
```

Then you can inject it like this:

kotlin

```
val userMapper: Mapper<UserDTO, User> by inject()
```

Or inside a constructor:

kotlin

```
class UserRepository(
    private val mapper: Mapper<UserDTO, User>
)
```

## ğŸ§  Why This Is Better for You

- âœ… **No annotations**: Keeps your classes clean and framework-agnostic.
    
- âœ… **Explicit bindings**: You control how each mapper is provided.
    
- âœ… **Flexible**: You can swap implementations easily for testing or customization.
    

## ğŸ§ª Bonus Tip: If You Have Many Mappers

You can group them in a separate module:

kotlin

```
val mapperModule = module {
    single<Mapper<UserDTO, User>> { UserMapper() }
    single<Mapper<PostDTO, Post>> { PostMapper() }
    // Add more as needed
}
```

Then include `mapperModule` in your app's Koin setup.

## ğŸ§­ Final Thoughts

With Koin, youâ€™re not tied to annotationsâ€”you define your dependencies in a **declarative, readable way**. Itâ€™s perfect for your modular architecture and keeps your mappers testable and clean.

Want help setting up a `mapperModule` for your current project? I can scaffold it based on your existing mappers.