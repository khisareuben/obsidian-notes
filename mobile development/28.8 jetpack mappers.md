
## 1. **Extension Function Mapper** (Simple & Clean)

This is the most common and Kotlin-idiomatic way when mapping is straightforward.

### âœ… Use when:

- Mapping is simple.
    
- You donâ€™t need dependencies.
    
- You want concise, readable code.
    

### ğŸ§© Example:



```kotlin
fun UserDTO.toDomain(): User {
    return User(
        id = id ?: 0,
        name = username ?: "Unknown",
        email = email ?: "no-email@example.com"
    )
}
```

## ğŸ§± 2. **Mapper Interface with** `convert(F): T`

This is a more formal, testable approachâ€”great for larger projects or when using dependency injection (like Koin).

### âœ… Use when:

- You want consistency across mappers.
    
- You need to inject mappers.
    
- You want to unit test mapping logic.
    

### ğŸ§© Interface:



```kotlin
interface Mapper<F, T> {
    fun convert(from: F): T
}
```

### ğŸ§© Implementation:



```kotlin
class UserMapper : Mapper<UserDTO, User> {
    override fun convert(from: UserDTO): User {
        return User(
            id = from.id ?: 0,
            name = from.username ?: "Unknown",
            email = from.email ?: "no-email@example.com"
        )
    }
}
```

### ğŸ§© Usage:



```kotlin
val userMapper = UserMapper()
val user = userMapper.convert(userDTO)
```

## ğŸ§  3. **Mapper Class with Named Function (**`map`**,** `transform`**, etc.)**

This is similar to the interface approach but without enforcing a generic contract.

### âœ… Use when:

- You want flexibility without generics.
    
- You have multiple mapping methods in one class.
    

### ğŸ§© Example:



```kotlin
class UserMapper {
    fun map(dto: UserDTO): User {
        return User(
            id = dto.id ?: 0,
            name = dto.username ?: "Unknown",
            email = dto.email ?: "no-email@example.com"
        )
    }
}
```

## ğŸ” 4. **Bidirectional Mapper (DTO â†” Model)**

Sometimes you need to convert both waysâ€”especially for caching, local DB, or sending data back to the server.

### âœ… Use when:

- You need both DTO â†’ Model and Model â†’ DTO.
    
- Youâ€™re syncing with local DB or sending POST requests.
    

### ğŸ§© Example:



```kotlin
class UserMapper {
    fun toDomain(dto: UserDTO): User { ... }
    fun toDto(model: User): UserDTO { ... }
}
```

## ğŸ§ª 5. **Functional Mapper (Lambda)**

For very simple cases, you can use a lambda or function reference.

### âœ… Use when:

- You donâ€™t need a class.
    
- You want quick mapping in a repository or use case.
    

### ğŸ§© Example:



```kotlin
val userMapper: (UserDTO) -> User = { dto ->
    User(
        id = dto.id ?: 0,
        name = dto.username ?: "Unknown",
        email = dto.email ?: "no-email@example.com"
    )
}
```

## ğŸ§­ Which One Should You Use?

|Style|Best For|Testable?|DI-Friendly?|Verbosity|
|---|---|---|---|---|
|Extension Function|Simple apps|âŒ|âŒ|âœ… Minimal|
|Mapper Interface|Scalable architecture|âœ…|âœ…|âš ï¸ Verbose|
|Mapper Class|Flexible logic|âœ…|âœ…|âš–ï¸ Balanced|
|Bidirectional Mapper|Syncing or POST APIs|âœ…|âœ…|âš ï¸ Verbose|
|Functional Mapper|Quick one-off use|âŒ|âŒ|âœ… Minimal|

If youâ€™re using **Koin**, the interface or class-based mappers are great because you can inject them easily. Want me to show you how to register a mapper in Koin and use it in a repository?