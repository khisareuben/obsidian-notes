
## 1. **Extension Function Mapper** (Simple & Clean)

This is the most common and Kotlin-idiomatic way when mapping is straightforward.

### ✅ Use when:

- Mapping is simple.
    
- You don’t need dependencies.
    
- You want concise, readable code.
    

### 🧩 Example:



```kotlin
fun UserDTO.toDomain(): User {
    return User(
        id = id ?: 0,
        name = username ?: "Unknown",
        email = email ?: "no-email@example.com"
    )
}
```

## 🧱 2. **Mapper Interface with** `convert(F): T`

This is a more formal, testable approach—great for larger projects or when using dependency injection (like Koin).

### ✅ Use when:

- You want consistency across mappers.
    
- You need to inject mappers.
    
- You want to unit test mapping logic.
    

### 🧩 Interface:



```kotlin
interface Mapper<F, T> {
    fun convert(from: F): T
}
```

just added this now so its not part of the code
```kotlin

fun <F,T> Mapper<F,T>.mapAll(list:List<F>) = list.map{map(it)}

```

### 🧩 Implementation:



```kotlin
class UserMapper : Mapper<UserDTO, User> {
    override fun convert(from: UserDTO): User {
        return User(
            id = from.id ?: 0,
            name = from.username ?: "Unknown",
            email = from.email ?: "no-email@example.com"
        )
    }
}
```

### 🧩 Usage:



```kotlin
val userMapper = UserMapper()
val user = userMapper.convert(userDTO)
```

## 🧠 3. **Mapper Class with Named Function (**`map`**,** `transform`**, etc.)**

This is similar to the interface approach but without enforcing a generic contract.

### ✅ Use when:

- You want flexibility without generics.
    
- You have multiple mapping methods in one class.
    

### 🧩 Example:



```kotlin
class UserMapper {
    fun map(dto: UserDTO): User {
        return User(
            id = dto.id ?: 0,
            name = dto.username ?: "Unknown",
            email = dto.email ?: "no-email@example.com"
        )
    }
}
```

## 🔁 4. **Bidirectional Mapper (DTO ↔ Model)**

Sometimes you need to convert both ways—especially for caching, local DB, or sending data back to the server.

### ✅ Use when:

- You need both DTO → Model and Model → DTO.
    
- You’re syncing with local DB or sending POST requests.
    

### 🧩 Example:



```kotlin
class UserMapper {
    fun toDomain(dto: UserDTO): User { ... }
    fun toDto(model: User): UserDTO { ... }
}
```

## 🧪 5. **Functional Mapper (Lambda)**

For very simple cases, you can use a lambda or function reference.

### ✅ Use when:

- You don’t need a class.
    
- You want quick mapping in a repository or use case.
    

### 🧩 Example:



```kotlin
val userMapper: (UserDTO) -> User = { dto ->
    User(
        id = dto.id ?: 0,
        name = dto.username ?: "Unknown",
        email = dto.email ?: "no-email@example.com"
    )
}
```

## 🧭 Which One Should You Use?

|Style|Best For|Testable?|DI-Friendly?|Verbosity|
|---|---|---|---|---|
|Extension Function|Simple apps|❌|❌|✅ Minimal|
|Mapper Interface|Scalable architecture|✅|✅|⚠️ Verbose|
|Mapper Class|Flexible logic|✅|✅|⚖️ Balanced|
|Bidirectional Mapper|Syncing or POST APIs|✅|✅|⚠️ Verbose|
|Functional Mapper|Quick one-off use|❌|❌|✅ Minimal|

If you’re using **Koin**, the interface or class-based mappers are great because you can inject them easily. Want me to show you how to register a mapper in Koin and use it in a repository?


## How to Provide Mappers in Koin

In Koin, you **don’t annotate classes**. Instead, you **declare them in your module** like this:

### 🧩 Example: Declaring `UserMapper` in a Koin Module

kotlin

```
val appModule = module {
    single<Mapper<UserDTO, User>> { UserMapper() }
}
```

Or if you want to use the concrete type directly:

kotlin

```
val appModule = module {
    single { UserMapper() }
}
```

Then you can inject it like this:

kotlin

```
val userMapper: Mapper<UserDTO, User> by inject()
```

Or inside a constructor:

kotlin

```
class UserRepository(
    private val mapper: Mapper<UserDTO, User>
)
```

## 🧠 Why This Is Better for You

- ✅ **No annotations**: Keeps your classes clean and framework-agnostic.
    
- ✅ **Explicit bindings**: You control how each mapper is provided.
    
- ✅ **Flexible**: You can swap implementations easily for testing or customization.
    

## 🧪 Bonus Tip: If You Have Many Mappers

You can group them in a separate module:

kotlin

```
val mapperModule = module {
    single<Mapper<UserDTO, User>> { UserMapper() }
    single<Mapper<PostDTO, Post>> { PostMapper() }
    // Add more as needed
}
```

Then include `mapperModule` in your app's Koin setup.

## 🧭 Final Thoughts

With Koin, you’re not tied to annotations—you define your dependencies in a **declarative, readable way**. It’s perfect for your modular architecture and keeps your mappers testable and clean.

Want help setting up a `mapperModule` for your current project? I can scaffold it based on your existing mappers.