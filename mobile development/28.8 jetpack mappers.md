

## 1. Remote Layer: DTOs (Data Transfer Objects)

### 🔍 What is a DTO?

A **DTO** is a class that mirrors the **exact structure of the JSON** returned by your API. It’s used only in the **data layer**, especially when working with Retrofit.

### 🧠 Why use DTOs?

- Keeps your app decoupled from the API.
    
- Lets you handle messy or inconsistent API responses.
    
- Makes it easier to change your domain logic without touching Retrofit.
    

### 🧩 Example:

Imagine your API returns this JSON:



```json
{
  "id": 101,
  "username": "harold_dev",
  "email": "harold@example.com"
}
```

You’d create a DTO like this:



```kotlin
data class UserDTO(
    val id: Int?,
    val username: String?,
    val email: String?
)
```

Notice:

- Fields are nullable (`Int?`, `String?`) because the API might omit them.
    
- You don’t enforce business rules here—just raw data.
    

## 🧠 2. Domain Layer: Models

### 🔍 What is a Model?

A **domain model** is a clean, safe representation of your data that your app actually uses. It’s designed for your app’s logic—not the API’s quirks.

### 🧠 Why use Models?

- Keeps your UI and business logic clean.
    
- Avoids nulls and unsafe types.
    
- Lets you rename fields, combine data, or enforce rules.
    

### 🧩 Example:



```kotlin
data class User(
    val id: Int,
    val name: String,
    val email: String
)
```

Notice:

- Fields are **non-null**.
    
- `username` is renamed to `name` to better fit your app’s terminology.
    
- You can add computed fields or logic later if needed.
    

## 🔄 3. Mapper: DTO → Model (and sometimes Model → DTO)

### 🔍 What is a Mapper?

A **mapper** is a function or class that converts a DTO into a domain model. It’s the bridge between the raw API data and your clean app logic.

### 🧠 Why use Mappers?

- Centralizes transformation logic.
    
- Handles nulls, defaults, renaming, formatting.
    
- Keeps your domain layer clean and independent.
    

### 🧩 Basic Mapper Example:



```kotlin
fun UserDTO.toDomain(): User {
    return User(
        id = this.id ?: 0,
        name = this.username ?: "Unknown",
        email = this.email ?: "no-email@example.com"
    )
}
```

### 🔍 What’s happening here?

- `id = this.id ?: 0` → If `id` is null, default to `0`.
    
- `name = this.username ?: "Unknown"` → Rename and provide fallback.
    
- `email = this.email ?: "no-email@example.com"` → Avoid nulls.
    

This mapper ensures your domain model is **safe**, **non-null**, and **ready for use** in your UI or business logic.

## 🧱 Summary Table

|Concept|Role|Coupled to API?|Nullable?|Used in UI?|Example|
|---|---|---|---|---|---|
|DTO|Raw API response|✅ Yes|✅ Often|❌ No|`UserDTO(id, username, email)`|
|Model|Clean app logic|❌ No|❌ Preferably not|✅ Yes|`User(id, name, email)`|
|Mapper|Converts DTO → Model|⚠️ Slightly|✅ Handles nulls|❌ No|`UserDTO.toDomain()`|

## 🛠️ Bonus: Mapper Class vs Extension Function

You can use either:

### ✅ Extension Function (simple cases):



```kotlin
fun UserDTO.toDomain(): User { ... }
```

### ✅ Mapper Class (complex or testable):



```kotlin
class UserMapper {
    fun map(dto: UserDTO): User { ... }
}
```

Use a class if:

- You want to inject dependencies (e.g., for formatting).
    
- You need to test the mapping logic separately.
    
- You have multiple DTOs to map.
    

Would you like to refactor the Post project using this structure? I can help you define the DTO, model, and mapper for the Post API step by step.