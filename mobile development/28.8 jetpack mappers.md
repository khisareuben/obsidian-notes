
## 1. **Extension Function Mapper** (Simple & Clean)

This is the most common and Kotlin-idiomatic way when mapping is straightforward.

### ✅ Use when:

- Mapping is simple.
    
- You don’t need dependencies.
    
- You want concise, readable code.
    

### 🧩 Example:



```kotlin
fun UserDTO.toDomain(): User {
    return User(
        id = id ?: 0,
        name = username ?: "Unknown",
        email = email ?: "no-email@example.com"
    )
}
```

## 🧱 2. **Mapper Interface with** `convert(F): T`

This is a more formal, testable approach—great for larger projects or when using dependency injection (like Koin).

### ✅ Use when:

- You want consistency across mappers.
    
- You need to inject mappers.
    
- You want to unit test mapping logic.
    

### 🧩 Interface:



```kotlin
interface Mapper<F, T> {
    fun convert(from: F): T
}
```

### 🧩 Implementation:



```kotlin
class UserMapper : Mapper<UserDTO, User> {
    override fun convert(from: UserDTO): User {
        return User(
            id = from.id ?: 0,
            name = from.username ?: "Unknown",
            email = from.email ?: "no-email@example.com"
        )
    }
}
```

### 🧩 Usage:



```kotlin
val userMapper = UserMapper()
val user = userMapper.convert(userDTO)
```

## 🧠 3. **Mapper Class with Named Function (**`map`**,** `transform`**, etc.)**

This is similar to the interface approach but without enforcing a generic contract.

### ✅ Use when:

- You want flexibility without generics.
    
- You have multiple mapping methods in one class.
    

### 🧩 Example:



```kotlin
class UserMapper {
    fun map(dto: UserDTO): User {
        return User(
            id = dto.id ?: 0,
            name = dto.username ?: "Unknown",
            email = dto.email ?: "no-email@example.com"
        )
    }
}
```

## 🔁 4. **Bidirectional Mapper (DTO ↔ Model)**

Sometimes you need to convert both ways—especially for caching, local DB, or sending data back to the server.

### ✅ Use when:

- You need both DTO → Model and Model → DTO.
    
- You’re syncing with local DB or sending POST requests.
    

### 🧩 Example:



```kotlin
class UserMapper {
    fun toDomain(dto: UserDTO): User { ... }
    fun toDto(model: User): UserDTO { ... }
}
```

## 🧪 5. **Functional Mapper (Lambda)**

For very simple cases, you can use a lambda or function reference.

### ✅ Use when:

- You don’t need a class.
    
- You want quick mapping in a repository or use case.
    

### 🧩 Example:



```kotlin
val userMapper: (UserDTO) -> User = { dto ->
    User(
        id = dto.id ?: 0,
        name = dto.username ?: "Unknown",
        email = dto.email ?: "no-email@example.com"
    )
}
```

## 🧭 Which One Should You Use?

|Style|Best For|Testable?|DI-Friendly?|Verbosity|
|---|---|---|---|---|
|Extension Function|Simple apps|❌|❌|✅ Minimal|
|Mapper Interface|Scalable architecture|✅|✅|⚠️ Verbose|
|Mapper Class|Flexible logic|✅|✅|⚖️ Balanced|
|Bidirectional Mapper|Syncing or POST APIs|✅|✅|⚠️ Verbose|
|Functional Mapper|Quick one-off use|❌|❌|✅ Minimal|

If you’re using **Koin**, the interface or class-based mappers are great because you can inject them easily. Want me to show you how to register a mapper in Koin and use it in a repository?