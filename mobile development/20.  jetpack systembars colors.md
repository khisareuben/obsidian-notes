
This includes the status bar and the navigation bar


```kotlin
Column(  
    modifier = Modifier.fillMaxSize()  
        .statusBarsPadding()  
        .navigationBarsPadding(),  
    horizontalAlignment = Alignment.CenterHorizontally  
)
```

10, 53 171
10 112 171
14 74 110



## Where to Put `enableEdgeToEdge()` with Theme Awareness

You should call it **inside a composable**, typically at the top of your `MainScreen` or `App` composable, **before** rendering your actual UI content. Here's a clean example:



```kotlin
@Composable
fun MyApp() {
    val isDarkTheme = isSystemInDarkTheme()

    // Apply edge-to-edge system bar styling
    SideEffect {
        enableEdgeToEdge(
            statusBarStyle = if (isDarkTheme) {
                SystemBarStyle.dark(Color.Transparent, Color.Transparent)
            } else {
                SystemBarStyle.light(Color.Transparent, Color.Transparent)
            },
            navigationBarStyle = if (isDarkTheme) {
                SystemBarStyle.dark(Color.Transparent, Color.Transparent)
            } else {
                SystemBarStyle.light(Color.Transparent, Color.Transparent)
            }
        )
    }

    // Your actual app UI
    MaterialTheme {
        Surface(modifier = Modifier.fillMaxSize()) {
            MainScreen()
        }
    }
}
```

## üîç Why Use `SideEffect`

- `SideEffect {}` ensures the system bar styling is applied **after composition**, avoiding recomposition issues.
    
- `isSystemInDarkTheme()` is safe here because it's inside a composable context.
    

## üß™ Bonus Tip for Preview Safety

If you're using `@Preview`, wrap the `enableEdgeToEdge()` logic in a runtime check to avoid preview crashes:



```kotlin
if (!LocalInspectionMode.current) {
    SideEffect {
        // enableEdgeToEdge() logic here
    }
}
```

Let me know if you want to integrate this with your custom theme setup or modular UI architecture ‚Äî I can help you make it clean and scalable.


### Option 1: Conditional Edge-to-Edge (only when needed)

Inside your `setContent { ... }`, you can wrap edge-to-edge logic in:



```kotlin
val isDark = isSystemInDarkTheme()
SideEffect {
    enableEdgeToEdge(
        statusBarStyle = if (isDark)
            SystemBarStyle.dark(Color.Black, Color.Black)
        else
            SystemBarStyle.light(Color.White, Color.White),
        navigationBarStyle = if (isDark)
            SystemBarStyle.dark(Color.Black, Color.Black)
        else
            SystemBarStyle.light(Color.White, Color.White)
    )
}
```

You still gain full control, but in a way that adapts to user settings without constantly tweaking everything.


# or

You just type this inside the default `enableEdgeToEdge()`

```kotlin

enableEdgeToEdge(  
    statusBarStyle = SystemBarStyle.light(  
        Color.TRANSPARENT , Color.TRANSPARENT  
    ),  
    navigationBarStyle = SystemBarStyle.light(  
        Color.TRANSPARENT, Color.TRANSPARENT  
    )  
)

```

# or

```kotlin
@Composable  
fun CustomizeStatusBar() {  
    val window = (LocalContext.current as Activity).window  
    SideEffect {  
        window.statusBarColor = Color(0xFF021346).toArgb()// Set status bar color  
    }  
}  
  
@Composable  
fun CustomizeNavigationBar() {  
    val window = (LocalContext.current as Activity).window  
    SideEffect {  
        window.navigationBarColor = Color(0xFF021346).toArgb() // Set navigation bar color  
    }  
}
```