
## 1. Add Paging Dependencies

In your `build.gradle.kts`:



```kotlin
implementation("androidx.paging:paging-runtime:3.3.6") // For non-Compose parts
implementation("androidx.paging:paging-compose:3.3.6") // Compose integration
```

## üîå 2. Update API to Accept Paging Parameters

Your existing Retrofit interface already fits Paging! Just tweak your method to return a `List<Post>` as you have:



```kotlin
@GET("posts")
suspend fun getPosts(
    @Query("_page") page: Int,
    @Query("_limit") limit: Int
): List<Post>
```

## üß† 3. Create a `PagingSource`

Inside `data/paging/PostPagingSource.kt`:



```kotlin
package com.example.learnretrofit.data.paging

import androidx.paging.PagingSource
import androidx.paging.PagingState
import com.example.learnretrofit.data.api.ApiService
import com.example.learnretrofit.data.model.Post

class PostPagingSource(private val apiService: ApiService) : PagingSource<Int, Post>() {
    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, Post> {
        return try {
            val page = params.key ?: 1
            val limit = params.loadSize
            val posts = apiService.getPosts(page, limit)
            LoadResult.Page(
                data = posts,
                prevKey = if (page == 1) null else page - 1,
                nextKey = if (posts.isEmpty()) null else page + 1
            )
        } catch (e: Exception) {
            LoadResult.Error(e)
        }
    }

    override fun getRefreshKey(state: PagingState<Int, Post>): Int? {
        return state.anchorPosition?.let { anchor ->
            state.closestPageToPosition(anchor)?.prevKey?.plus(1)
                ?: state.closestPageToPosition(anchor)?.nextKey?.minus(1)
        }
    }
}
```

## üß™ 4. Create a `Pager` in Your Repository

In `PostRepositoryImpl.kt`:



```kotlin
import androidx.paging.Pager
import androidx.paging.PagingConfig
import androidx.paging.PagingData
import kotlinx.coroutines.flow.Flow

override fun getPagedPosts(): Flow<PagingData<Post>> {
    return Pager(
        config = PagingConfig(pageSize = 5),
        pagingSourceFactory = { PostPagingSource(apiService) }
    ).flow
}
```

Update your `PostRepository.kt`:



```kotlin
fun getPagedPosts(): Flow<PagingData<Post>>
```

## üß† 5. Update ViewModel for Paging

In `PostViewModel.kt`:



```kotlin
import androidx.paging.PagingData
import androidx.paging.cachedIn
import kotlinx.coroutines.flow.*

class PostViewModel(
    private val repository: PostRepository
) : ViewModel() {

    val pagedPosts: Flow<PagingData<Post>> = repository
        .getPagedPosts()
        .cachedIn(viewModelScope)
}
```

## üé® 6. Paging-Aware Composable

In `PostListScreen.kt`, replace `LazyColumn` with `LazyPagingItems`:



```kotlin
import androidx.paging.compose.collectAsLazyPagingItems
import androidx.paging.compose.items

@Composable
fun PostListScreen(
    viewModel: PostViewModel = koinViewModel(),
    navController: NavHostController
) {
    val posts = viewModel.pagedPosts.collectAsLazyPagingItems()

    LazyColumn(
        modifier = Modifier.padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        items(posts) { post ->
            post?.let {
                PostCard(post = it) {
                    navController.navigate("postDetail/${it.id}/${it.title}/${it.body}")
                }
            }
        }

        when {
            posts.loadState.append is LoadState.Loading -> {
                item {
                    CircularProgressIndicator(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .wrapContentWidth(Alignment.CenterHorizontally),
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }

            posts.loadState.refresh is LoadState.Error -> {
                item {
                    Text(
                        text = "Failed to load posts. Try again.",
                        modifier = Modifier.padding(16.dp)
                    )
                }
            }
        }
    }
}
```

## ‚öôÔ∏è 7. Koin Module Update

Nothing breaks! Just make sure your DI still provides `ApiService` and `PostRepository`.

### ‚ú® Summary

|Feature|Manual Pagination|Paging 3|
|---|---|---|
|Trigger on scroll|‚úÖ|‚úÖ (auto-handled)|
|Caching support|‚ùå|‚úÖ via Room|
|Retry/error handling|Manual|‚úÖ built-in|
|UI integration|Manual logic|‚úÖ with `LazyPagingItems`|
|Learning investment|Low|Medium (but reusable)|

### üì¶ `PagingSource<Int, Post>`

This class defines **how to load paginated data**, where:

- `Int` is the key type (e.g. page number).
    
- `Post` is the data model you're loading.
    

This is what connects your Retrofit API to the Paging library.

### üöö `load()` Function

This is triggered by the Paging system when it needs more data. Here's what each piece does:



```kotlin
val page = params.key ?: 1
```

- Grabs the current page to load, or defaults to `1` (i.e. first page).
    



```kotlin
val limit = params.loadSize
val posts = apiService.getPosts(page, limit)
```

- Uses your Retrofit service to fetch data for the current page.
    
- `loadSize` is how many items to request.
    



```kotlin
LoadResult.Page(
    data = posts,
    prevKey = if (page == 1) null else page - 1,
    nextKey = if (posts.isEmpty()) null else page + 1
)
```

- Constructs the paginated result:
    
    - `data = posts`: The actual data returned.
        
    - `prevKey`: Tells Paging what the previous page is (null if you're at the first page).
        
    - `nextKey`: Determines the next page (null if you‚Äôve hit the end).
        



```kotlin
catch (e: Exception) {
    LoadResult.Error(e)
}
```

- Handles any network errors gracefully.
    

### üîÅ `getRefreshKey()`

Used to figure out **which page to reload** if your list is refreshed (like a swipe-to-refresh).



```kotlin
val anchor = state.anchorPosition
```

- Gets the user's most recently accessed item index (say, from a scroll position).
    



```kotlin
state.closestPageToPosition(anchor)?.prevKey?.plus(1)
    ?: state.closestPageToPosition(anchor)?.nextKey?.minus(1)
```

- This logic figures out which page should be fetched again by nudging toward the closest known key from that anchor position.
    

### üß† Why This Matters

This setup gives your app:

- Efficient scrolling with minimal memory usage.
    
- Retry and refresh capabilities.
    
- Seamless API integration with Compose‚Äôs lazy components.
    

If you want, we can refactor this to use `PostUI` with a mapper inline ‚Äî or prep it for `RemoteMediator` + Room caching. Just tell me how deep you want to go.

