

## Step-by-Step: Room + ViewModel + Koin + Jetpack Compose

### ‚úÖ 1. Add Koin Dependencies

In your `build.gradle` (app-level):



```groovy
plugins {
    id 'kotlin-kapt'
}

dependencies {
    // Koin core
    implementation("io.insert-koin:koin-android:4.1.0")  
	implementation("io.insert-koin:koin-androidx-compose:4.1.0")

    // Room
    implementation "androidx.room:room-runtime:2.6.1"
    kapt "androidx.room:room-compiler:2.6.1"
    implementation "androidx.room:room-ktx:2.6.1"

    // ViewModel
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0"
}
```

#### ‚úÖ 1. **Create the columns of the database** : These are the different sections that will be in your database /data
#### `Note.kt`



```kotlin
@Entity(tableName = "note")  
data class Note(  
    val noteName: String,  
    val noteBody: String,  
    @PrimaryKey(autoGenerate = true)  
    val noteId: Int = 0  
)
```

#### `NoteDao.kt`

#### 2. **Create the Dao(Data access object)** : This will help interact with the database and performing functions like insert, delete, update /data

```kotlin
@Dao
interface NoteDao {  
    @Upsert  
    suspend fun upsertNote(note: Note)  
    @Delete  
    suspend fun deleteNote(note: Note)  
  
    @Query("SELECT * FROM note")  
    fun getAllNotes() : Flow<List<Note>>  
}
```

#### `NoteDatabase.kt`

#### **Create the database** : This will integrate the columns and the dao together /data

```kotlin
@Database(  
    entities = [Note::class],  
    version = 1,  
)  
  
abstract class NoteDatabase: RoomDatabase() {  
  
    abstract val dao: NoteDao  
  
}
```

### ‚úÖ 3. Create Repository and ViewModel

#### `NoteRepository.kt`

#### 4. Create a notes event (real action)/presentation

```kotlin
class NoteRepository(private val db : NoteDatabase) {  
  
    suspend fun upsertNote(note: Note) {  
        db.dao.upsertNote(note)  
    }  
  
    suspend fun deleteNote(note: Note){  
        db.dao.deleteNote(note)  
    }  
  
    fun getAllNotes() = db.dao.getAllNotes()  
  
}
```

#### `NoteViewModel.kt`

#### 5. Create your viewModel /presentation

```kotlin
class NoteViewModel(private val repository: Repository): ViewModel() {  
  
    val getAllData: StateFlow<List<Todo>> = repository.getAllData()  
    .stateIn(  
        scope = viewModelScope,  
        started = SharingStarted.WhileSubscribed(5000),  
        initialValue = emptyList()  
    )  
  
    fun upsertNote(note: Note) {  
        viewModelScope.launch{  
            repository.upsertNote(note)  
        }  
    }  
    fun deleteNote(note: Note) {  
        viewModelScope.launch{  
            repository.deleteNote(note)  
        }  
    }  
  
  
}
```



## What Is a Koin Module?

A **Koin module** is like a **recipe** that tells Koin how to create and provide the things your app needs‚Äîlike your database, DAO, repository, and ViewModel.

You write this recipe once, and Koin uses it to "cook up" the objects whenever your app asks for them.

## üß© Let's Break Down the Koin Module Line by Line

Here‚Äôs the code again:



```kotlin
val appModule = module {
    single {
        Room.databaseBuilder(
        get(), 
        NoteDatabase::class.java, 
        "note.db"
        ).build()
    }
    single { get<NoteDatabase>().noteDao() }
    single { NoteRepository(get()) }
    viewModel { NoteViewModel(get()) }
}
```

Now let‚Äôs explain each line:

### üß± `single { ... }` ‚Äî What Does It Mean?

- `single` means: ‚ÄúKoin, please create **one instance** of this and reuse it everywhere.‚Äù
    
- It‚Äôs like saying: ‚ÄúMake one database, one DAO, one repository, and share them.‚Äù
    

### üîπ Line 1: Create the Room Database



```kotlin
single {
    Room.databaseBuilder(get(), NoteDatabase::class.java, "note.db").build()
}
```

- This tells Koin how to create your Room database.
    
- `get()` means: ‚ÄúKoin, give me the `Context` (which it already knows from your Application).‚Äù
    
- So this line is the same as:
    
    
    
    ```kotlin
    Room.databaseBuilder(applicationContext, NoteDatabase::class.java, "note.db").build()
    ```
    

‚úÖ Now Koin knows how to build your database.

### üîπ Line 2: Create the DAO



```kotlin
single { get<NoteDatabase>().noteDao() }
```

- This says: ‚ÄúKoin, get the `NoteDatabase` you just created, and call `.noteDao()` on it.‚Äù
    
- So now Koin knows how to give you the DAO (Data Access Object).
    

‚úÖ Now Koin can give you the DAO whenever you need it.

### üîπ Line 3: Create the Repository



```kotlin
single { NoteRepository(get()) }
```

- This says: ‚ÄúKoin, create a `NoteRepository`, and give it the DAO you just created.‚Äù
    
- `get()` here means: ‚ÄúGive me the DAO.‚Äù
    

‚úÖ Now Koin knows how to build your repository.

### üîπ Line 4: Create the ViewModel



```kotlin
viewModel { NoteViewModel(get()) }
```

- This says: ‚ÄúKoin, create a `NoteViewModel`, and give it the repository.‚Äù
    
- `viewModel {}` is a special Koin function that knows how to work with Android‚Äôs ViewModel system.
    

‚úÖ Now Koin can give you the ViewModel in your UI code.

## üß† Summary of the Flow

Here‚Äôs how everything connects:

```
Context (from Application)
   ‚Üì
Room.databaseBuilder(...) ‚Üí NoteDatabase
   ‚Üì
NoteDatabase.noteDao() ‚Üí NoteDao
   ‚Üì
NoteRepository(NoteDao)
   ‚Üì
NoteViewModel(NoteRepository)
```

Koin builds this chain for you automatically. You just describe how to build each piece.

## üß™ Do You Need to Memorize This?

No! But you should understand the pattern:

- `single { ... }` ‚Üí For things you want one copy of (like database, DAO, repository)
    
- `viewModel { ... }` ‚Üí For ViewModels
    
- `get<T>()` ‚Üí Ask Koin to give you something it already knows how to build
    

Once you understand this pattern, you can build anything with Koin.


This is the UI but its not complete so put it in a function and pass the viewmodel as an argument...


```kotlin

Surface(  
    modifier = Modifier.fillMaxSize(),  
    color = MaterialTheme.colorScheme.background  
) {  
    var showDialog by remember { mutableStateOf(false) } // Initially false  
    var name by remember { mutableStateOf("") }  
    var body by remember { mutableStateOf("") }  
    val note = Note(name, body)  
    val noteList by viewModel.getAllData.collectAsState()
    // State to hold the note that might be deleted  
    var noteToDelete by remember { mutableStateOf<Note?>(null) }  
  
    Column(  
        modifier = Modifier.padding(16.dp),  
        verticalArrangement = Arrangement.spacedBy(12.dp)  
    ) {  
        Button(onClick = {  
            viewModel.upsertNote(note)  
        }) {  
            Text(text = "set data")  
        }  
        TextField(  
            value = name,  
            onValueChange = { name = it },  
            placeholder = { Text(text = "name") }  
        )  
        TextField(  
            value = body,  
            onValueChange = { body = it },  
            placeholder = { Text(text = "body") }  
        )  
  
        LazyColumn {  
            items(noteList) { currentNote ->  
                Column(  
                    Modifier.clickable {  
                        noteToDelete = currentNote // Set the note to delete  
                        showDialog = true      // Show the dialog  
                    }  
                ) {  
                    Text(text = "Name: ${currentNote.noteName}")  
                    Spacer(modifier = Modifier.padding(10.dp))  
                    Text(text = "Name: ${currentNote.noteBody}") // Assuming this was meant to be noteBody  
                    HorizontalDivider(  
                        modifier = Modifier.padding(6.dp),  
                        thickness = DividerDefaults.Thickness,  
                        color = DividerDefaults.color  
                    )  
                }  
            }        }    }  
    // Conditionally display the AlertDialog here, outside the LazyColumn's item scope  
    if (showDialog && noteToDelete != null) {  
        AlertDialog(  
            onDismissRequest = {  
                showDialog = false  
                noteToDelete = null // Reset the note to delete  
            },  
            title = { Text(text = "Delete note") },  
            text = { Text(text = "Are you sure you want to delete this note: ${noteToDelete?.noteName}?") },  
            confirmButton = {  
                TextButton(onClick = {  
                    noteToDelete?.let { viewModel.deleteNote(it) }  
                    showDialog = false  
                    noteToDelete = null // Reset the note to delete  
                }  
                ) { Text(text = "Yes") }  
            },  
            dismissButton = {  
                TextButton(onClick = {  
                    showDialog = false  
                    noteToDelete = null // Reset the note to delete  
                }  
                ) { Text(text = "No") }  
            }        )  
    }}

```