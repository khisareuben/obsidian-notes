
1. Add the dependencies for retrofit, dagger hilt, navigation
2. Create the package layers: `data` - `domain` - `presentation` - `common` - `di` 


## Adding the resource file
This helps deal with the success, error and loading state

`common/Resource.kt`  I prefer name it `Utils/` rather that common

```kotlin

sealed class Resource<T>(val data: T? = null, val message: String? = null) {  
    class Success<T>(data: T) : Resource<T>(data)  
    class Error<T>(message: String, data: T? = null) : Resource<T>(data, message)  
    class Loading<T>(data: T? = null): Resource<T>(data)  
}

```

`common/Constants.kt` 

```kotlin

object Constants {  
  
    const val BASE_URL = "https://api.coinpaprika.com/"  
    const val PARAM_COIN_ID = "coinId"
  
}

```


## Adding the dto

`https://api.coinpaprika.com/v1/coins` -> copy the code in the first bracket(7) ->  Right click on remote/dto -> new -> Kotlin data file class from Json -> Paste the json code -> name the file

`data/remote/dto/CoinDto.kt`
```kotlin

import com.google.gson.annotations.SerializedName  
  
data class CoinDto(  
    val id: String,  
    @SerializedName("is_active")  
    val isActive: Boolean,  
    @SerializedName("is_new")  
    val isNew: Boolean,  
    val name: String,  
    val rank: Int,  
    val symbol: String,  
    val type: String  
)

```

convert it to a local model using a mapper
`domain/model/Coin.kt`

```kotlin

import com.example.cryptocurrency.data.remote.dto.CoinDto  
  
data class Coin(  
    val id: String,  
    val isActive: Boolean,  
    val name: String,  
    val rank: Int,  
    val symbol: String  
)  
  
// this is a mapper  
  
fun CoinDto.toCoin(): Coin {  
    return Coin(  
        id = id,  
        isActive = isActive,  
        name = name,  
        rank = rank,  
        symbol = symbol  
    )  
}

```

**Repeat the same process with Getting the coin details**

`https://api.coinpaprika.com/v1/coins/btc-bitcoin` -> copy all the code ->  Right click on remote/dto -> new -> Kotlin data file class from Json -> Paste the json code -> name the file

`data/remote/dto/CoinDetailDto.kt`
```kotlin

import com.google.gson.annotations.SerializedName  
  
data class CoinDetailDto(  
    val description: String,  
    @SerializedName("development_status")  
    val developmentStatus: String,  
    @SerializedName("first_data_at")  
    val firstDataAt: String,  
    @SerializedName("hardware_wallet")  
    val hardwareWallet: Boolean,  
    @SerializedName("hash_algorithm")  
    val hashAlgorithm: String,  
    val id: String,  
    @SerializedName("is_active")  
    val isActive: Boolean,  
    @SerializedName("is_new")  
    val isNew: Boolean,  
    @SerializedName("last_data_at")  
    val lastDataAt: String,  
    val links: Links,  
    @SerializedName("links_extended")  
    val linksExtended: List<LinksExtended>,  
    val logo: String,  
    val message: String,  
    val name: String,  
    @SerializedName("open_source")  
    val openSource: Boolean,  
    @SerializedName("org_structure")  
    val orgStructure: String,  
    @SerializedName("proof_type")  
    val proofType: String,  
    val rank: Int,  
    @SerializedName("started_at")  
    val startedAt: String,  
    val symbol: String,  
    val tags: List<Tag>,  
    val team: List<TeamMember>,  
    val type: String,  
    val whitepaper: Whitepaper  
)

```

convert it to a local model using a mapper
`domain/model/Coin.kt`

```kotlin

import com.example.cryptocurrency.data.remote.dto.CoinDetailDto  
import com.example.cryptocurrency.data.remote.dto.TeamMember  
  
data class CoinDetail(  
    val coinId: String,  
    val name: String,  
    val description: String,  
    val symbol: String,  
    val rank: Int,  
    val isActive: Boolean,  
    val tags: List<String>,  
    val team: List<TeamMember>  
)  
  
fun CoinDetailDto.toCoinDetail(): CoinDetail {  
    return CoinDetail(  
        coinId = id,  
        name = name,  
        description = description,  
        symbol = symbol,  
        rank = rank,  
        isActive = isActive,  
        tags = tags.map { it.name },  
        team = team  
    )  
}

```


## Adding the api

`data/remote/CoinPaprikaApi.kt`

```kotlin

import com.example.cryptocurrency.data.remote.dto.CoinDetailDto  
import com.example.cryptocurrency.data.remote.dto.CoinDto  
import retrofit2.http.GET  
import retrofit2.http.Path  
  
interface CoinPaprikaApi {  
  
    @GET("/v1/coins")  
    suspend fun getCoins(): List<CoinDto>  
    
    // @Path means replacing the {coinId} with the actual coinId which is a string(e.g btc-bitcoin)
    // https://api.coinpaprika.com/v1/coins/btc-bitcoin
  
    @GET("/v1/coins/{coinId}")  
    suspend fun getCoinById(@Path("coinId") coinId: String): CoinDetailDto  
  
}

```


## Adding the repository

`domain/repository/CoinRepository.kt` 

```kotlin

import com.example.cryptocurrency.data.remote.dto.CoinDetailDto  
import com.example.cryptocurrency.data.remote.dto.CoinDto  
  
interface CoinRepository {  
  
    suspend fun getCoins(): List<CoinDto>  
  
    suspend fun getCoinById(coinId: String): CoinDetailDto  
  
}

```


`data/repository/CoinRepositoryImpl.kt`

```kotlin

  
class CoinRepositoryImpl @Inject constructor(  
    private  val api: CoinPaprikaApi  
) : CoinRepository {  
  
    override suspend fun getCoins(): List<CoinDto> {  
        return api.getCoins()  
    }  
  
    override suspend fun getCoinById(coinId: String): CoinDetailDto {  
        return api.getCoinById(coinId)  
    }  
}

```


## Adding the UseCases

`domain/use_case/get_coins/GetCoinsUseCase.kt`

```kotlin

class GetCoinsUseCase @Inject constructor(  
    private val repository: CoinRepository  
) {  
  
    operator fun invoke(): Flow<Resource<List<Coin>>> = flow {  
        try {  
            emit(Resource.Loading<List<Coin>>())  
            val coins = repository.getCoins().map { it.toCoin() }  
            emit(Resource.Success<List<Coin>>(coins))  
        }catch (e: HttpException) {  
            //if there is an error response from the api/http request  
            emit(Resource.Error<List<Coin>>(e.localizedMessage ?: "An unexpected error occured"))  
        }catch (e: IOException) {  
            // if we can't communicate with the api at all  
            emit(Resource.Error<List<Coin>>("Couldn't reach server. Check your internet connection"))  
        }  
    }  
  
}

```

`domain/use_case/get_coin/GetCoinUseCase.kt`

```kotlin

class GetCoinUseCase @Inject constructor(  
    private val repository: CoinRepository  
) {  
  
    operator fun invoke(coinId: String): Flow<Resource<CoinDetail>> = flow {  
        try {  
            emit(Resource.Loading<CoinDetail>())  
            val coin = repository.getCoinById(coinId).toCoinDetail()  
            emit(Resource.Success<CoinDetail>(coin))  
        }catch (e: HttpException) {  
            //if there is an error response from the api/http request  
            emit(Resource.Error<CoinDetail>(e.localizedMessage ?: "An unexpected error occured"))  
        }catch (e: IOException) {  
            // if we can't communicate with the api at all  
            emit(Resource.Error<CoinDetail>("Couldn't reach server. Check your internet connection"))  
        }  
    }  
  
}

```


## Adding dagger hilt

`di/AppModule.kt`

```kotlin

@Module  
@InstallIn(SingletonComponent::class)  
object AppModule {  
  
    @Provides  
    @Singleton    fun providePaprikaApi(): CoinPaprikaApi {  
        return Retrofit.Builder()  
            .baseUrl(Constants.BASE_URL)  
            .addConverterFactory(GsonConverterFactory.create())  
            .build()  
            .create(CoinPaprikaApi::class.java)  
    }  
  
    @Provides  
    @Singleton    fun provideCoinRepository(api: CoinPaprikaApi): CoinRepository {  
        return CoinRepositoryImpl(api)  
    }  
  
}

```

in the root folder

`/MyApp.kt`


```kotlin

@HiltAndroidApp  
class MyApp: Application()

```

add it in the `AndroidManifest.xml`
